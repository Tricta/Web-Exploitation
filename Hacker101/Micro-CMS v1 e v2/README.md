<h1 align="center">  Made by: Tricta</h1>

<font color="red">
	<b>
	Observação: A pesquisa sobre as vulnerabilidades web de acordo com a demanda constam ao decorrer do write-up para melhor organização e um material mais completo e autoexplicativo.
	</b>
</font>
# Micro-CMS v1: Difficulty -> Easy

### Ambiente
Ao entrar no desafio, ele nos propõe uma página simples, para a criação de páginas com markdown com 3 "links" na tela.

A primeira e a segunda página foram criadas para testar a funcionalidade do site, ambas podemos editar:
![img](./img/Pasted%20image%2020240308152230.png)

A terceira página server para criarmos novas páginas:
![img](./img/Pasted%20image%2020240308160426.png)

### Flag 0
Olhando que para criar nossa página precisamos dar input em algum texto e que podemos usar tags html para por elementos em nossa página, deduzi que poderia ser uma vulnerabilidade de XSS(Cross-site scripting), então tentei colocar a tag ```<script>alert(1)</script>``` no titulo:
![img](./img/Pasted%20image%2020240308165114.png)

E quando criamos a página, obtemos a primeira flag:
![img](./img/Pasted%20image%2020240308165306.png)
### Flag 1
Após conseguir a primeira flag, pensei em tentar fazer a mesma coisa no conteúdo da página, porém ele faz a filtragem do input
![img](./img/Pasted%20image%2020240308194831.png)

Ou seja, ele remove a tag ```<script></script>```:
![img](./img/Pasted%20image%2020240308194950.png)

Logo, já pensei de cara em usar uma tag que executasse código javascript sem ser a ```<script></script>```, usando assim uma tag de imagem por exemplo, e quando ocorrer um erro ao carrega-la, ela chamara a função javascript:
![img](./img/Pasted%20image%2020240308234923.png)

Confesso que demorei um pouco para entender que tinha que ver o código fonte da página para ver a flag hehe...
![img](./img/Pasted%20image%2020240308235731.png)

**Nome da vulnerabilidade**: Stored XSS (Cross-site Scripting)
**Impacto**:
- Redirecionar usuários para um site malicioso. (Phising)
- Capturar as teclas digitadas pelos usuários.
- Acessar o histórico do navegador dos usuários e o conteúdo da área de transferência.
- Executar exploits baseados em navegador da Web (por exemplo, travar o navegador).
- Obter as informações do cookie de um usuário que está logado em um site.
- Roubar o token de sessão de login, permitindo que o invasor interaja com o aplicativo como a vítima sem saber sua senha.
- Forçar o usuário a enviar solicitações controladas pelo invasor a um servidor.
- Mudar o conteúdo de uma página.
- Enganar a vítima para que divulgue sua senha para o aplicativo ou outros aplicativos.
- Infectar a vítima com outro código malicioso usando uma vulnerabilidade no próprio navegador da Web, possivelmente assumindo o computador da vítima.
**Exemplos**:
1. Em 2021, o Avast divulgou uma vulnerabilidade XSS em sua ferramenta de Antivírus para Desktop. A vulnerabilidade permitia que um atacante injetasse código malicioso no nome do SSID de uma rede WiFi. Quando um dispositivo Windows com o antivírus Avast se conectasse a essa rede, o XSS era executado. A exploração era possível porque o programa antivírus da Avast exibia o nome do SSID sem sanitização, permitindo que um atacante injetasse uma carga útil. Após a execução do script, era exibida uma falsa solicitação de login ao usuário, aumentando a probabilidade de cair nela. O pesquisador que descobriu a vulnerabilidade, YoKo Kho, a relatou para o Avast e recebeu uma recompensa de US$ 5000. A vulnerabilidade também afeta o AVG, e ambas as empresas lançaram correções para ela. Outros programas de antivírus, como Bitdefender e Comodo, também foram encontrados com vulnerabilidades. Para mais informações: https://latesthackingnews.com/2019/11/10/serious-xss-vulnerability-found-in-avast-desktop-antivirus-for-windows/amp/

2. Pesquisadores descobriram uma vulnerabilidade de XSS no Microsoft Edge. O bug afetou o recurso de tradução automática do navegador. Ao visitar um site em outro idioma e tentar traduzi-lo, pop-ups apareciam, levando à descoberta da vulnerabilidade XSS. O bug estava na função startPageTranslation e processava incorretamente tags HTML de imagem com o caractere ">". Isso permitiu a execução de código JavaScript sem validação e sanitização adequadas. Para demonstrar o problema, os pesquisadores criaram um arquivo de prova de conceito e foram capazes de hackear sites se o usuário-alvo os abrisse com a tradução automática ativada. A Microsoft foi informada da vulnerabilidade e lançou uma correção com a versão 91.0.864.59 do navegador Edge, juntamente com outra correção de vulnerabilidade. Os pesquisadores receberam uma recompensa de US$ 20.000 por relatar a falha. Para mais informações: https://latesthackingnews.com/2021/06/30/universal-xss-vulnerability-in-microsoft-edge/amp/

**Exemplo de código vulnerável --> PHP:**
```
<!DOCTYPE html>
<html>
<head>
    <title>Notifications</title>
</head>
<body>
    <h1>Notifications</h1>

    <?php
	    if ($_SERVER["REQUEST_METHOD"] == "POST") {
	        $name = $_POST["name"];
	        $message = $_POST["message"];

			// Podemo notar nas 4 linhas seguintes o uso do arquivo notifications.log
			// para armazenar as notificações enviadas pelo usuário sem a sanitização
			// adequada do código, fazendo com que tags de script possam ser salvas
			// dentro do arquivo e criando assim sua persistencia (daí o nome stored)

	        $file = 'Notifications.log';
	        $current = file_get_contents($file);
	        $current .= "<strong>$name:</strong> $message<br>";
	        file_put_contents($file, $current);
	    }
    ?>

    <form method="post" action="<?php echo $_SERVER["PHP_SELF"]; ?>">
        <label for="name">Name:</label>
        <input type="text" id="name" name="name"><br>
        <label for="message">Message:</label>
        <textarea id="message" name="message"></textarea><br>
        <input type="submit" value="Submit">
    </form>

    <h2>Past Notifications</h2>

    <?php
	    // Aqui o arquivo notifications.log é lido e colocado no documento html
	    // que é interpretado pelo navegador
	    echo file_get_contents('Notifications.log');
    ?>
</body>
</html>
```

**Exploits públicos**: 
1. Showdoc 2.10.3 - Stored Cross-Site Scripting (XSS): https://www.exploit-db.com/exploits/50941
2. FusionInvoice 2023-1.0 - Stored XSS (Cross-Site Scripting): https://www.exploit-db.com/exploits/51480

### Flag 2
Se navegarmos entre as páginas existentes, podemos ver nas urls, os números das páginas:
![img](./img/Pasted%20image%2020240309013737.png)
![img](./img/Pasted%20image%2020240309013838.png)

Indo para a página que criamos, podemos ver que a um salto do index 2 pra 12:
![img](./img/Pasted%20image%2020240309014225.png)

Então decidi tentar navegar entre as páginas entre esses dois index, e encontrei essa mensagem no index 7:
![img](./img/Pasted%20image%2020240309014420.png)

Já que não temos permissão para ver o conteúdo... e se tentarmos editar? Lá estará nossa flag!
![img](./img/Pasted%20image%2020240309015652.png)

**Nome da vulnerabilidade**: Path traversal
**Impacto**:
- Vazamento de informações confidenciais
- Execução remota de código
- Modificação ou exclusão de arquivos críticos
- Ataques de negação de serviço
**Exemplos**:
1. Uma vulnerabilidade na aplicação do gerenciador de dispositivos da Kyocera permite que cibercriminosos realizem ataques de Path traversal em empresas afetadas. O atacante pode modificar o caminho do local de backup para um caminho UNC e tentar autenticar um compartilhamento controlado por eles. No entanto, o atacante deve estar na mesma rede que o Gerenciador de Dispositivos Kyocera. A Trustwave conduziu testes e descobriu que interceptar e modificar a solicitação de acesso ou enviar diretamente a solicitação para o ponto final da aplicação poderia definir caminhos da convenção universal de nomenclatura (UNC) como locais de backup. A Kyocera lançou uma atualização de segurança com um patch de validação. Dispositivos afetados devem ser atualizados para proteção contra exploração, pois essa vulnerabilidade pode levar à exposição de credenciais. Para mais informações: https://www.cisoadvisor.com.br/impressoras-kyocera-estao-expostas-a-ataques-de-path-traversal/

2. Uma vulnerabilidade crítica (CVE-2023-2825) foi descoberta no GitLab Community Edition e Enterprise Edition 16.0.0, com uma pontuação CVSS de 10. A vulnerabilidade permite que um atacante leia remotamente qualquer arquivo no servidor sem autenticação quando um documento está anexado a um projeto público aninhado em cinco grupos. A falha pode ser explorada ao contornar verificações adicionando "..%2F" à URL. Para mais informações: https://www.stormshield.com/news/security-alert-cve20232825-stormshield-products-response/ 

**Exemplo de código vulnerável --> PHP:**
```
<?php
	$arquivo = $_GET['arquivo'];
	$caminho_completo = "./path/" . $arquivo;
	
	// Faz a leitura de arquivos sem a devida sanitização
	$conteudo = file_get_contents($caminho_completo);
	
	echo "Conteúdo do arquivo: <br>";
	
	// Exibi o conteúdo do arquivo lido podendo conter dados sensíveis
	echo $conteudo;
?>
```

**Exploits públicos**: 
1. copyparty 1.8.2 - Directory Traversal: https://www.exploit-db.com/exploits/51636
2. Apache HTTP Server 2.4.49 - Path Traversal & Remote Code Execution (RCE): https://www.exploit-db.com/exploits/50383

### Flag 3
Essa eu confesso que demorei um pouco pra sacar... mas o site para armazenar essas páginas criadas guarda elas em um banco de dados mysql, guardando a url, título e corpo do site...
Poderíamos tentar a partir da url fazer um ataque de sql injection acrescentando uma aspas simples no final da url, obtendo assim a última flag:
![img](./img/Pasted%20image%2020240309021106.png)

**Nome da vulnerabilidade**: SQL Injection
**Impacto**:
- Expor dados confidenciais.
- Comprometer a integridade dos dados.
- Comprometer a privacidade dos usuários.
- Conceder a um invasor acesso de administrador a seu sistema.
- Dar a um invasor acesso geral a seu sistema.
**Exemplos**:
1. Pesquisadores da empresa de cibersegurança Check Point descobriram que cibercriminosos poderiam ter acesso à conta de qualquer jogador de Fortnite explorando falhas de segurança no site da Epic Games. Ao redirecionar o tráfego da página de login principal para outra página no site, hackers poderiam roubar tokens de login, que são chaves digitais que permitem aos jogadores fazer login em suas contas do Fortnite em outras plataformas, como Facebook, Xbox Live e Nintendo. O ataque seria iniciado ao atrair um jogador para clicar em um link malicioso. Uma vez clicado, os hackers poderiam forçar o serviço de login, como o Facebook, a reenviar o token de login para um subdomínio antigo e vulnerável da Epic Games. Este subdomínio continha duas vulnerabilidades comuns: SQL Injection e Cross-site Scripting. Essas falhas permitiram que os pesquisadores roubassem o token de login da vítima e acessassem sua conta do Fortnite. Não está claro se hackers maliciosos exploraram essas vulnerabilidades antes de serem corrigidas pela Epic Games. Empresas como Epic Games e Facebook são suscetíveis a tais ataques devido ao uso de autenticação de login único, que permite aos usuários fazer login em várias plataformas usando um conjunto de credenciais. Para mais informações: https://www.vice.com/en/article/vba5nb/fornite-login-hack-epic-games-website

2. Uma vulnerabilidade significativa de SQL Injection, conhecida como CVE-2023-20211, foi descoberta no Cisco Unified Communications Manager (Unified CM) e no Cisco Unified Communications Manager Session Management Edition (Unified CM SME). Essa vulnerabilidade permite que um atacante remoto com privilégios de baixo nível conduza ataques de SQL Injection nos sistemas afetados. A vulnerabilidade surge devido à falta de validação para entrada fornecida pelo usuário, permitindo até mesmo que usuários com permissões apenas de leitura explorem o sistema. Para mais informações: https://socradar.io/what-you-need-to-know-about-cisco-unified-communications-manager-sql-injection-vulnerability-cve-2023-20211/

**Exemplo de código vulnerável --> PHP:**
```
<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
    <h2>Login</h2>

    <form method="post" action="<?php echo $_SERVER["PHP_SELF"]; ?>">
        user:
        <input type="text" id="user" name="user"><br>
        Password:
        <input type="text" id="pass" name="pass"><br>
        <input type="submit" value="Login">
    </form>

    <?php
        $server= "localhost";
        $username = "root";
        $password = "usbw";
        $db= "sqlinjection";
  
        $conn = new mysqli($server, $username, $password, $db);

        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }

        if ($_SERVER["REQUEST_METHOD"] == "POST") {
            $username = $_POST['user'];
            $password = $_POST['pass'];

			// Query SQL sendo concatenada diretamente a variáveis, o que 
			// deixa o usuário livre para manipular a string como
			// ele quiser, abrindo brecha para a falha de SQL Injection
            $sql = "SELECT * FROM users WHERE username='$username' AND pass='$password'";

            $result = $conn->query($sql);
  
            if ($result->num_rows > 0) {
                echo "<script>alert('Login bem-sucedido!')</script>";
            } else {
                echo "<script>alert('Login falho')</script>";
            }
        }
  
        $conn->close();
    ?>
</body>
</html>
```

**Exploits públicos**: 
1. Cmaps v8.0 - SQL injection: https://www.exploit-db.com/exploits/51422
2. CMS Made Simple < 2.2.10 - SQL Injection: https://www.exploit-db.com/exploits/46635

# Micro-CMS v2: Difficulty -> Moderate
### Ambiente
O ambiente é o mesmo da versão 1, porém o criador nos diz que corrigiu as vulnerabilidades encontradas anteriormente:
![img](./img/Pasted%20image%2020240309021350.png)

Agora também possuímos um login para poder criar novas páginas:
![img](./img/Pasted%20image%2020240309021444.png)

### Flag 0
Bom, é uma tela de login... A primeira coisa que me veio a cabeça foi sql injection, mas eu não sabia muito então fui dar uma estudada.
![img](./img/Pasted%20image%2020240309022111.png)

Hack the box quase completo, mas foi o suficiente pra resolver o desafio rsrs... Provavelmente quando esse write-up for enviado já devo ter terminado todos.

Tentei fazer primeiro alterando a logica da query string:
![img](./img/Pasted%20image%2020240309022536.png)

Mas não deu certo... pesquisei mais sobre union injection, que não havia intendido muito bem, e  depois de um tempinho mexendo no CTF saiu essa query:
```
' UNION SELECT 'pass'; -- 
```

O que rola em alguns sistemas, o que convenhamos que não é o "ideal", é pegar o usuário digitado através de um WHERE no banco de dados e retornar a senha e compara com o digitado pelo usuário

E digitando a senha 'pass' que será "adicionada" na coluna de senhas do banco de dados através do UNION, entramos no sistema, por conta desse retorno de senhas não filtradas

no fim a query do banco de dados ficaria mais ou menos assim:
```
query = 'SELECT password FROM USERS WHERE username='' UNION SELECT 'pass'; -- ' AND password=''
```

![img](./img/Pasted%20image%2020240309023845.png)

Entrando na página desbloqueada "Private Page", obtemos a flag:
![img](./img/Pasted%20image%2020240309023935.png)

### Flag 1
Algumas horinhas depois, inspecionando a página de sucesso no login achei o seguinte comentário:
![img](./img/Pasted%20image%2020240309024715.png)

Pensei em tentar extrair os dados do banco porém iam ser muitas queries, ia demorar muito, além de muita pesquisa em volta do assunto... Optei então por uma ferramenta automatizada, no caso o sqlmap:
![img](./img/Pasted%20image%2020240312011850.png)

**Ps:** No arquivo request.txt há a mesma requisição enviada pela página, foi extraída utilizando o Burp:
![img](./img/Pasted%20image%2020240312012056.png)

E por fim, na análise feita pelo sqlmap, conseguimos extrair os dados salvos na tabela "admins":
![img](./img/Pasted%20image%2020240312110805.png)

Realizando o Input desses dados, conseguimos nossa flag:
![img](./img/Pasted%20image%2020240312111643.png)
### Flag 2
A ultima flag demorei bastante para conseguir, tive que usar o burp para modificar o tipo da requisição que ele fazia para a página 3, a mesma da "Private Page", e no final cai em uma vulnerabilidade de Path traversal... Porque no sistemas de rotas da aplicação, alguém deixou o post retornar o conteúdo da página que deveria estar bloqueado para todos os tipos de requisições:
![img](./img/Pasted%20image%2020240309025950.png)

E aí está nossa ultima flag! Gostei bastante desse CTF...

